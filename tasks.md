**Задание I**

1. Установить рабочее окружение
2. Создать в группе **ozoncp** репозиторий для своего проекта **ocp-template-api** -- for example ozoncp/ocp-task-api
3. В данном репозитории создать пакет **cmd/ozon-template-api**

**Задание II**

В пакете **internal/utils** вашего репозитория нужно реализовать экспортируемые функции для
1.  Разделение на слайса на батчи - исходный слайс конвертировать в слайс слайсов - чанки одинкового размера (кроме последнего)
2.  Обратный ключ - происходит конвертация отображения ("ключ-значение") в отображение ("значение-ключ")
3.  Фильтрация по захордкоженному списку - нужно отфильтровать входной слайс по критерию отсутствия элемента в захардкоженном списке

**Задание III**

1. Используя defer и функтор реализовать открытие и закрытие файла в цикле
2. Для своей предметной области описать структуры и
реализовать методы работы с ними к примеру `String()`
```
type User struct {
 UserId uint64
 // ...
}
```
3. Реализовать в пакете utils для своих структур функции:
  - Батчевого разделения слайса на слайс слайсов, на пример:
```
func SplitToBulks(users []User, butchSize uint)[][]User {
}
```
  - Конвертации слайса от структуры в отображение, где ключ идентификатор структуры, а значение сама структура, на пример:
```
func ...([]User) (map[uint64]User, error) {
}
```

**Задание IV**

1. Добавить интерфейсы `Repo` и `Flusher`
2. Сгенерировать моки для `Repo` с помощью mockgen
3. Реализовать имплементацию `flusher` для интерфейса `Flusher`
4. Написать тестовые сценарии с помощью **ginkgo** и **gomega**

**Задание V**

Нужно в пакете **saver** имплементировать `Saver` интерфейс, с возможностью писать в хранилище данные, через `Flusher`, сброс данных происходит во flusher по определенному таймауту или по вызову метода `Close`
package saver
```
type Saver interface {
	Save(entity models.Entity) // заменить на свою сущность
    // Init()
	Close()
}
// NewSaver возвращает Saver с поддержкой переодического сохранения
func NewSaver(
	capacity uint,
	flusher flusher.Flusher,
  // ...
) Saver {
  // ...
}
```
До сброса в хранилище, данные хранятся в slice. который пренадлежит saver-у. задания capacity данного slice-a идет на этапе конструирование -  при вызове NewSaver

**Задание VI**

Нужно реализовать **CRUD** сервис, для хранения информации для Вашей главной сущности (можно при желание и для дополнительной сущности, реализовать еще один сервис)
ручки будут `CreateEntity` , `DescribeEntity`, `ListEntities`, `RemoveEntity` - для синхронного общения (gRPC). _Entity - для примера_
Нужно описать **proto** файлы и сгенерировать код в **pkg** директорию
**Makefile** можно посмотреть в **ocp-task-api**
Имплементация ручек - просто логгирование с помощью **zerolog**
Добавить в **cmd/ocp-entity-api/main.go** код по поднятию **gRPC** сервиса


**Задание VII**

“Реализовать методы” для интерфейса Repo</br>
Заменить в ручках код логирования на работу с repo (+логгирование)</br>
Пробросить в конструирование api параметр repo Repo</br>
Написать модульные тесты для ручек (создать необходимые моки)</br>

**Задание VIII**

Реализовать `MultiCreateEntity` ручку для множественного добавления сущностей в базу. Добавление сделать батчами.</br>
Создавать родительский спан в `MultiCreateEntity`. На каждый батч нужно создать дочерний спан. В спан добавить размер отправленных данных.</br>
Реализовать `UpdateEntity` ручку для обновления сущности.</br>
Добавить `Producer`-a для создания **CUD** событий (_Create/Update/Delete_) в кафку.</br>
Добавить метрики на кол-во успешных вызовов для **CUD** ручек (_Create/Update/Delete_)</br>
